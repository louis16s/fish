"""
Generate C++ sources that embed UI assets into firmware flash.

Input (source of truth):
  - data/ui/index.html
  - data/ui/config.html
  - data/ui/logs.html
  - data/ui/pond_gate.svg
  - data/ui/bg_long.svg

Output (generated):
  - src/WS_UI_Assets.h
  - src/WS_UI_Assets.cpp
"""

from __future__ import annotations

from pathlib import Path
import hashlib
import sys


ASSETS: list[dict[str, str]] = [
    {
        "id": "UI_INDEX_HTML",
        "src": "data/ui/index.html",
        "path": "/ui/index.html",
        "content_type": "text/html; charset=utf-8",
    },
    {
        "id": "UI_CONFIG_HTML",
        "src": "data/ui/config.html",
        "path": "/ui/config.html",
        "content_type": "text/html; charset=utf-8",
    },
    {
        "id": "UI_LOGS_HTML",
        "src": "data/ui/logs.html",
        "path": "/ui/logs.html",
        "content_type": "text/html; charset=utf-8",
    },
    {
        "id": "UI_POND_GATE_SVG",
        "src": "data/ui/pond_gate.svg",
        "path": "/ui/pond_gate.svg",
        "content_type": "image/svg+xml",
    },
    {
        "id": "UI_BG_LONG_SVG",
        "src": "data/ui/bg_long.svg",
        "path": "/ui/bg_long.svg",
        "content_type": "image/svg+xml",
    },
]


def _project_dir() -> Path:
    # In PlatformIO/SCons extra scripts, `__file__` may be undefined depending on how SCons exec()'s the script.
    # Prefer PlatformIO's env to locate the project root reliably.
    try:
        e = globals().get("env", None)
        if e is not None:
            p = e.subst("$PROJECT_DIR")
            if p:
                return Path(p)
    except Exception:
        pass

    try:
        return Path(__file__).resolve().parent.parent  # type: ignore[name-defined]
    except Exception:
        return Path.cwd()


def _sha256(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()


def _format_bytes_as_cpp_initializer(data: bytes, indent: str = "  ", per_line: int = 12) -> str:
    # Hex keeps output ASCII-only and avoids encoding pitfalls.
    parts = [f"0x{byte:02x}" for byte in data]
    lines: list[str] = []
    for i in range(0, len(parts), per_line):
        lines.append(indent + ", ".join(parts[i : i + per_line]))
    return ",\n".join(lines)


def _write_if_changed(path: Path, content: str) -> bool:
    if path.exists():
        old = path.read_text(encoding="utf-8")
        if old == content:
            return False
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8", newline="\n")
    return True


def main() -> int:
    project_dir = _project_dir()
    out_h = project_dir / "src" / "WS_UI_Assets.h"
    out_cpp = project_dir / "src" / "WS_UI_Assets.cpp"

    resolved = []
    for a in ASSETS:
        src = project_dir / a["src"]
        if not src.exists():
            print(f"[embed-ui] missing input: {src}", file=sys.stderr)
            return 2
        data = src.read_bytes()
        resolved.append({**a, "src_abs": src, "data": data, "sha256": _sha256(data)})

    header = """\
#pragma once

#include <stddef.h>
#include <stdint.h>

// Auto-generated by scripts/embed_ui_assets.py. Do not edit manually.
struct WS_UI_Asset {
  const char* path;          // URL path, e.g. "/ui/index.html"
  const char* content_type;  // HTTP Content-Type
  const uint8_t* data;       // Flash-resident bytes (PROGMEM)
  size_t len;                // Byte length
};

// Returns nullptr if the asset isn't embedded in firmware.
const WS_UI_Asset* WS_UI_FindAsset(const char* path);
"""

    cpp_lines: list[str] = []
    cpp_lines.append('#include "WS_UI_Assets.h"')
    cpp_lines.append("")
    cpp_lines.append("#include <Arduino.h>")
    cpp_lines.append("#include <pgmspace.h>")
    cpp_lines.append("#include <string.h>")
    cpp_lines.append("")
    cpp_lines.append("// Auto-generated by scripts/embed_ui_assets.py. Do not edit manually.")
    cpp_lines.append("")

    cpp_lines.append("namespace {")
    for a in resolved:
        arr_name = f'k_{a["id"]}'
        cpp_lines.append(f"static const uint8_t {arr_name}[] PROGMEM = {{")
        if a["data"]:
            cpp_lines.append(_format_bytes_as_cpp_initializer(a["data"]))
        cpp_lines.append("};")
        cpp_lines.append("")

    cpp_lines.append("static const WS_UI_Asset kAssets[] = {")
    for a in resolved:
        arr_name = f'k_{a["id"]}'
        cpp_lines.append(
            f'  {{"{a["path"]}", "{a["content_type"]}", {arr_name}, sizeof({arr_name})}}, // sha256:{a["sha256"]}'
        )
    cpp_lines.append("};")
    cpp_lines.append("} // namespace")
    cpp_lines.append("")
    cpp_lines.append("const WS_UI_Asset* WS_UI_FindAsset(const char* path)")
    cpp_lines.append("{")
    cpp_lines.append("  if (path == nullptr || path[0] == '\\0') {")
    cpp_lines.append("    return nullptr;")
    cpp_lines.append("  }")
    cpp_lines.append("  for (size_t i = 0; i < (sizeof(kAssets) / sizeof(kAssets[0])); i++) {")
    cpp_lines.append("    if (strcmp(path, kAssets[i].path) == 0) {")
    cpp_lines.append("      return &kAssets[i];")
    cpp_lines.append("    }")
    cpp_lines.append("  }")
    cpp_lines.append("  return nullptr;")
    cpp_lines.append("}")
    cpp_lines.append("")

    cpp = "\n".join(cpp_lines)

    wrote_h = _write_if_changed(out_h, header)
    wrote_cpp = _write_if_changed(out_cpp, cpp)

    if wrote_h:
        print(f"[embed-ui] wrote {out_h}")
    else:
        print(f"[embed-ui] up-to-date {out_h}")
    if wrote_cpp:
        print(f"[embed-ui] wrote {out_cpp}")
    else:
        print(f"[embed-ui] up-to-date {out_cpp}")
    return 0

# PlatformIO extra_script entry point:
# When executed by PlatformIO/SCons, `Import` is available.
_is_platformio = False
try:
    Import("env")  # type: ignore[name-defined]  # noqa: F821
    _is_platformio = True
except Exception:
    _is_platformio = False

if _is_platformio:
    rc = main()
    if rc != 0:
        raise RuntimeError(f"[embed-ui] failed with code {rc}")
elif __name__ == "__main__":
    raise SystemExit(main())
